<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Usage · Legendre Polynomials</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Legendre Polynomials</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Legendre.jl Documentation</a></li><li><span class="tocitem">Associated Legendre Functions</span><ul><li><a class="tocitem" href="../intro/">Introduction</a></li><li class="is-active"><a class="tocitem" href>Usage</a><ul class="internal"><li><a class="tocitem" href="#Calculating-scalar-values-1"><span>Calculating scalar values</span></a></li><li><a class="tocitem" href="#Calculating-all-values-up-to-a-given-ℓ_\\mathrm{max}-1"><span>Calculating all values up to a given <span>$ℓ_\mathrm{max}$</span></span></a></li><li><a class="tocitem" href="#Broadcasting-over-multiple-arguments-1"><span>Broadcasting over multiple arguments</span></a></li><li><a class="tocitem" href="#Precomputed-recursion-factors-1"><span>Precomputed recursion factors</span></a></li><li><a class="tocitem" href="#Footnotes-1"><span>Footnotes</span></a></li></ul></li><li><a class="tocitem" href="../devdocs/">Developer Documentation</a></li><li><a class="tocitem" href="../references/">Literature/References</a></li></ul></li><li><span class="tocitem">API Reference</span><ul><li><a class="tocitem" href="../../lib/public/">Public</a></li><li><a class="tocitem" href="../../lib/private/">Private</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Associated Legendre Functions</a></li><li class="is-active"><a href>Usage</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Usage</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/jmert/Legendre.jl.git/blob/master/docs/src/man/usage.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="usage-1"><a class="docs-heading-anchor" href="#usage-1">Usage</a><a class="docs-heading-anchor-permalink" href="#usage-1" title="Permalink"></a></h1><ul><li><a href="#usage-1">Usage</a></li><ul><li><a href="#Calculating-scalar-values-1">Calculating scalar values</a></li><li><a href="#Calculating-all-values-up-to-a-given-ℓ_\\mathrm{max}-1">Calculating all values up to a given <span>$ℓ_\mathrm{max}$</span></a></li><li><a href="#Broadcasting-over-multiple-arguments-1">Broadcasting over multiple arguments</a></li><li><a href="#Precomputed-recursion-factors-1">Precomputed recursion factors</a></li><li><a href="#Footnotes-1">Footnotes</a></li></ul></ul><h2 id="Calculating-scalar-values-1"><a class="docs-heading-anchor" href="#Calculating-scalar-values-1">Calculating scalar values</a><a class="docs-heading-anchor-permalink" href="#Calculating-scalar-values-1" title="Permalink"></a></h2><p>At its simplest, the associated Legendre polynomial <span>$P_ℓ^m(x)$</span> is computed by calling <a href="../../lib/public/#Legendre.Plm"><code>Legendre.Plm</code></a>. For example, to compute <span>$P_2^1(0.5)$</span>,</p><pre><code class="language-julia-repl">julia&gt; using Legendre

julia&gt; Plm(2, 1, 0.5)
-1.299038105676658</code></pre><p>In the context of CMB analysis, a common use of the associated Legendre polynomials is to compute the spherical harmonics <span>$Y_{ℓm}(θ,ϕ)$</span>:</p><div>\[\begin{align}
    \begin{aligned}
    Y_{ℓm}(θ,ϕ) &amp;≡ N_ℓ^m P_ℓ^m(\cos θ) e^{imϕ} \\
    &amp;\text{where } N_ℓ^m ≡ \sqrt{\frac{2ℓ+1}{4π} \frac{(ℓ-m)!}{(ℓ+m)!}}
    \end{aligned}
\end{align}\]</div><p>The function <a href="../../lib/public/#Legendre.Nlm-Union{Tuple{T}, Tuple{Type{T},Integer,Integer}} where T"><code>Legendre.Nlm</code></a> calculates the normalization factor <span>$N_ℓ^m$</span>:</p><pre><code class="language-julia-repl">julia&gt; Nlm(2, 0)
0.6307831305050401

julia&gt; Nlm(2, 0) * Plm(2, 0, 0.5)
-0.07884789131313001</code></pre><p>An important fact about the associated Legendre polynomials is that for <span>$m &gt; 0$</span>, <span>$P_ℓ^m(x)$</span> diverges to <span>$∞$</span> as <span>$ℓ → ∞$</span> <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>. For even moderately large pairs of <span>$(ℓ,m)$</span>, numerical underflow and overflow make computing the spherical harmonics impossible this way:</p><pre><code class="language-julia-repl">julia&gt; n = Nlm(157, 150)      # Underflows
0.0

julia&gt; p = Plm(157, 150, 0.5) # Overflows
Inf

julia&gt; n * p                  # Undefined
NaN</code></pre><p>One way around this would be to just use extended precision arithmetic</p><pre><code class="language-julia-repl">julia&gt; n = Nlm(BigFloat, 157, 150)
4.14800666209481424285411223457923933542541063872695815968861285171699012214351e-314

julia&gt; p = Plm(157, 150, big&quot;0.5&quot;)
4.768286486602206390406601862422168575170463348990958242752608686436785229641823e+308

julia&gt; Float64(n * p)
1.9778884113202627e-5</code></pre><p>but at the expense of much more computationally expensive calculations.</p><p>An alternative way forward is to directly calculate the spherical harmonic normalized associated Legendre polynomials <span>$λ_ℓ^m(x)$</span> so that the spherical harmonics are defined as</p><div>\[\begin{align}
    \begin{aligned}
    Y_{ℓm}(θ,ϕ) &amp;= λ_ℓ^m(\cos θ) e^{imϕ} \\
    &amp; \text{where } λ_ℓ^m(x) ≡ N_ℓ^m P_ℓ^m(x)
    \end{aligned}
\end{align}\]</div><p><a href="../../lib/public/#Legendre.λlm"><code>Legendre.λlm</code></a> implements this scheme and avoids the under/overflow of computing the normalization separately from the function:</p><pre><code class="language-julia-repl">julia&gt; λlm(157, 150, 0.5)
1.977888411320258e-5</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>We are not just limited to efficient and numerically stable computation of <span>$λ_ℓ^m(x)$</span>; the package supports arbitrary normalizations.  For further information on implementing custom Legendre normalizations, see the <a href="../devdocs/#customnorm-1">Custom normalizations</a> section.</p></div></div><h2 id="Calculating-all-values-up-to-a-given-ℓ_\\mathrm{max}-1"><a class="docs-heading-anchor" href="#Calculating-all-values-up-to-a-given-ℓ_\\mathrm{max}-1">Calculating all values up to a given <span>$ℓ_\mathrm{max}$</span></a><a class="docs-heading-anchor-permalink" href="#Calculating-all-values-up-to-a-given-ℓ_\\mathrm{max}-1" title="Permalink"></a></h2><p>Because calculating a particular Legendre polynomial value is the end result of running a recurrence relation, looping evaluation of <span>$P_ℓ^m(x)$</span> for all <span>$ℓ$</span> is inefficient and redoes a lot of work:</p><pre><code class="language-julia-repl">julia&gt; λ = zeros(701);

julia&gt; @time λ[3:701] = [λlm(l, 2, 0.5) for l in 2:700];
  0.063346 seconds (56.42 k allocations: 2.539 MiB)</code></pre><p>It&#39;s far more efficient to accumulate the intermediate terms while running the recurrence relations. Both of <code>Plm</code> and <code>λlm</code> have modifying counterparts, <a href="../../lib/public/#Legendre.Plm!"><code>Plm!</code></a> and <a href="../../lib/public/#Legendre.λlm!"><code>λlm!</code></a> respectively, which fill an appropriately sized vector for a specified <span>$ℓ_\mathrm{max}$</span>.</p><pre><code class="language-julia-repl">julia&gt; @time λlm!(λ, 700, 2, 0.5);
  0.000162 seconds (14 allocations: 320 bytes)</code></pre><p>On my machine, this ends up being roughly 400 times faster!</p><p>If all Legendre polynomial values for some <span>$x$</span> over all <span>$ℓ ∈ [0,ℓ_\mathrm{max}]$</span> and <span>$m ∈ [0,ℓ]$</span> are required, instead supply an output matrix into which the lower triangle of values is filled:</p><pre><code class="language-julia-repl">julia&gt; Λ = zeros(701, 701);

julia&gt; λlm!(Λ, 700, 700, 0.5);

julia&gt; Λ[701,3] == λlm(700, 2, 0.5)   # N.B. 1-based indexing of the array!
true</code></pre><h2 id="Broadcasting-over-multiple-arguments-1"><a class="docs-heading-anchor" href="#Broadcasting-over-multiple-arguments-1">Broadcasting over multiple arguments</a><a class="docs-heading-anchor-permalink" href="#Broadcasting-over-multiple-arguments-1" title="Permalink"></a></h2><p>The Legendre polynomials can be evaluated over multiple arguments <span>$x$</span> as well by using Julia&#39;s standard broadcasting syntax:</p><pre><code class="language-julia-repl">julia&gt; λlm.(2, 0, range(-1.0, 1.0, length=5))
5-element Array{Float64,1}:
  0.63078313050504
 -0.07884789131313
 -0.31539156525252
 -0.07884789131313
  0.63078313050504</code></pre><p>Broadcasting has been specialized for calls to <code>Pl</code>, <code>Plm</code>, and <code>λlm</code> to avoid the overhead inherent in calling the scalar functions multiple times:</p><pre><code class="language-julia-repl">julia&gt; z = range(-1.0, 1.0, length=500);

julia&gt; @time [λlm(2, 0, i) for i in z];
  0.054037 seconds (54.23 k allocations: 2.447 MiB)

julia&gt; @time λlm.(2, 0, z);
  0.000032 seconds (13 allocations: 36.719 KiB)</code></pre><p>In fact, the shape of <code>z</code> is preserved, so any matrix shape can be used:</p><pre><code class="language-julia-repl">julia&gt; λlm.(2, 0, rand(3,3,3))
3×3×3 Array{Float64,3}:
[:, :, 1] =
  0.326489  -0.285639  -0.313698
  0.46875   -0.241804  -0.310982
 -0.289767  -0.276217  -0.191519

[:, :, 2] =
  0.580778   -0.251413   0.091097
  0.0093121   0.468216  -0.00159624
 -0.0402128  -0.288992   0.397937

[:, :, 3] =
  0.57083   -0.311711  -0.313631
  0.242235  -0.197404  -0.247441
 -0.107      0.242107  -0.311164</code></pre><p>Obtaining the Legendre polynomials over multiple <span>$\ell$</span> and/or <span>$m$</span> values for many arguments can be done via broadcasting as well. The degree <code>l</code> must be a <code>UnitRange</code> starting at zero, and <code>m</code> may be either a scalar integer (to calculate all <span>$\ell$</span> for a fixed <span>$m$</span>) or a <code>UnitRange</code> starting at zero as well. For example, to compute the <span>$P_\ell^0(z)$</span> and <span>$P_\ell^2(z)$</span> coefficients to an <span>$\ell_{\mathrm{max}} = 700$</span>, one could execute</p><pre><code class="language-julia-repl">julia&gt; summary(Plm.(0:700, 0:2, z))
&quot;500×701×3 Array{Float64,3}&quot;</code></pre><p>The output array will have between 0 and 2 more dimensions more than the dimensionality of the input arguments depending on the calling convention. For scalar values of <code>l</code> and <code>m</code>, the output will be the same shape as <code>z</code> with no extra trailing dimensions. If instead <code>l</code> is a <code>UnitRange</code>, the output dimensionality increases by one, and the trailing dimension runs over the degrees <span>$\ell$</span>; switching to <code>m</code> a <code>UnitRange</code> as well, the output dimensionality is two greater than <code>z</code>, with the penultimate and final dimensions running over <span>$\ell$</span> and <span>$m$</span>, respectively.</p><h2 id="Precomputed-recursion-factors-1"><a class="docs-heading-anchor" href="#Precomputed-recursion-factors-1">Precomputed recursion factors</a><a class="docs-heading-anchor-permalink" href="#Precomputed-recursion-factors-1" title="Permalink"></a></h2><p>A final trick to accelerating calculation of any normalization of the associated Legendre polynomials is to pre-compute the appropriate recursion relation coefficients.</p><p>At a low level, <code>Plm</code>/<code>Plm!</code> and <code>λlm</code>/<code>λlm!</code> are simple wrappers around the general <a href="../../lib/public/#Legendre.legendre-Tuple{AbstractLegendreNorm,Integer,Integer,Number}"><code>legendre</code></a>/<a href="../../lib/public/#Legendre.legendre!-Tuple{AbstractLegendreNorm,Any,Integer,Integer,Any}"><code>legendre!</code></a> functions. The trait type <a href="../../lib/public/#Legendre.LegendreUnitNorm"><code>LegendreUnitNorm</code></a> dispatches internal functions to compute <span>$P_ℓ^m(x)$</span>:</p><pre><code class="language-julia-repl">julia&gt; legendre(LegendreUnitNorm(), 5, 2, 0.5) == Plm(5, 2, 0.5)
true</code></pre><p>and <a href="../../lib/public/#Legendre.LegendreSphereNorm"><code>LegendreSphereNorm</code></a> does the same for <span>$λ_ℓ^m(x)$</span>:</p><pre><code class="language-julia-repl">julia&gt; legendre(LegendreSphereNorm(), 5, 2, 0.5) == λlm(5, 2, 0.5)
true</code></pre><p>The type <a href="../../lib/public/#Legendre.LegendreNormCoeff"><code>LegendreNormCoeff</code></a> stores the coefficients for a particular normalization (and value type) so that the coefficients must only be calculated once. Aliases for the unit and spherical normalizations are provided by default, <a href="../../lib/public/#Legendre.LegendreUnitCoeff"><code>LegendreUnitCoeff</code></a> and <a href="../../lib/public/#Legendre.LegendreSphereCoeff"><code>LegendreSphereCoeff</code></a> respectively.</p><pre><code class="language-julia-repl">julia&gt; coeff = LegendreSphereCoeff{Float64}(700);

julia&gt; legendre(coeff, 5, 2, 0.5)
-0.15888479843070935</code></pre><div class="admonition is-warning"><header class="admonition-header">Performance Note</header><div class="admonition-body"><p>Choosing whether to use the pre-computed coefficients or not should be guided by benchmarking and performance profiling. Modern processors can perform many floating point operations in the time it takes to load the coefficients from memory, so depending on the complexity of the normalization, you may actually achieve better performance by recomputing the recursion coefficients on demand.</p></div></div><p>Notice that due to its flexibility, <code>legendre!</code> requires explicit <code>lmax</code> and <code>mmax</code> arguments even though the <code>LegendreNormCoeff</code> has a <code>lmax</code> and <code>mmax</code> set during construction. This allows us to pass both a coefficient cache and output array which are larger than the computed set of coefficients. For example, the output matrix and cache used above each support computing the Legendre polynomials up to <span>$\ell = 700$</span>, but if we only need <span>$\ell \le 2$</span>, we can avoid computing terms beyond our required problem size.</p><pre><code class="language-julia-repl">julia&gt; fill!(Λ, 0);

julia&gt; legendre!(coeff, Λ, 2, 2, 0.5);

julia&gt; Λ[1:5, 1:5]
5×5 Array{Float64,2}:
  0.282095    0.0       0.0       0.0  0.0
  0.244301   -0.299207  0.0       0.0  0.0
 -0.0788479  -0.334523  0.289706  0.0  0.0
  0.0         0.0       0.0       0.0  0.0
  0.0         0.0       0.0       0.0  0.0</code></pre><hr/><h2 id="Footnotes-1"><a class="docs-heading-anchor" href="#Footnotes-1">Footnotes</a><a class="docs-heading-anchor-permalink" href="#Footnotes-1" title="Permalink"></a></h2><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a><p>Specifically, the envelope of <span>$P_ℓ^m(x)$</span> which bounds the local extrema for all values of <span>$x$</span> can be shown to be</p><div>\[    \left| P_ℓ^m(\cos θ) \right| ≤ \frac{Γ(ℓ+m+1)}{Γ(ℓ+\frac{3}{2})}
        \left( \frac{2}{π \sin θ} \right)^{1/2}\]</div><p>(see Eq. 8.10.7 (p336) of Abramowitz and Stegun, “Handbook of Mathematical Functions” 10th printing (1972)). For fixed <span>$m$</span> and any <span>$x$</span>, we take the asymptotic limit as <span>$ℓ → ∞$</span> and simplify <span>$Γ(z)$</span> via Stirling&#39;s approximation to get the scaling of the associated Legendre polynomial envelope</p><div>\[    \DeclareMathOperator*{\env}{env}
    \env_{ℓ→∞}\left( P_ℓ^m \right) ∝ ℓ^{m - 1/2} \text{ .}\]</div><p>In contrast, the normalization factor <span>$N_ℓ^m$</span> scales as <span>$ℓ^{1/2 - m}$</span>, exactly canceling the scaling of <span>$\env\left(P_ℓ^m\right)$</span>, so overall the spherical harmonic normalized Legendre polynomials <span>$λ_ℓ^m(x)$</span> asymptote to some constant envelope:</p><div>\[    \env_{ℓ→∞} \left( λ_ℓ^m \right) ∝ ℓ^0 = \text{constant .}\]</div></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../intro/">« Introduction</a><a class="docs-footer-nextpage" href="../devdocs/">Developer Documentation »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 4 June 2020 03:40">Thursday 4 June 2020</span>. Using Julia version 1.2.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
