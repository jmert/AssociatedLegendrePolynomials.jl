<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Usage · Associated Legendre Polynomials</title><meta name="title" content="Usage · Associated Legendre Polynomials"/><meta property="og:title" content="Usage · Associated Legendre Polynomials"/><meta property="twitter:title" content="Usage · Associated Legendre Polynomials"/><meta name="description" content="Documentation for Associated Legendre Polynomials."/><meta property="og:description" content="Documentation for Associated Legendre Polynomials."/><meta property="twitter:description" content="Documentation for Associated Legendre Polynomials."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Associated Legendre Polynomials</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">AssociatedLegendrePolynomials.jl Documentation</a></li><li><span class="tocitem">Associated Legendre Functions</span><ul><li><a class="tocitem" href="../intro/">Introduction</a></li><li class="is-active"><a class="tocitem" href>Usage</a><ul class="internal"><li><a class="tocitem" href="#Calculating-scalar-values"><span>Calculating scalar values</span></a></li><li><a class="tocitem" href="#Calculating-multiple-degrees/orders"><span>Calculating multiple degrees/orders</span></a></li><li><a class="tocitem" href="#In-place-calculations"><span>In-place calculations</span></a></li><li><a class="tocitem" href="#Precomputed-recursion-factors"><span>Precomputed recursion factors</span></a></li><li><a class="tocitem" href="#Footnotes"><span>Footnotes</span></a></li></ul></li><li><a class="tocitem" href="../devdocs/">Developer Documentation</a></li><li><a class="tocitem" href="../references/">Literature/References</a></li></ul></li><li><a class="tocitem" href="../../lib/public/">API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Associated Legendre Functions</a></li><li class="is-active"><a href>Usage</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Usage</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/jmert/AssociatedLegendrePolynomials.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/jmert/AssociatedLegendrePolynomials.jl/blob/master/docs/src/man/usage.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="usage"><a class="docs-heading-anchor" href="#usage">Usage</a><a id="usage-1"></a><a class="docs-heading-anchor-permalink" href="#usage" title="Permalink"></a></h1><ul><li><a href="#usage">Usage</a></li><li class="no-marker"><ul><li><a href="#Calculating-scalar-values">Calculating scalar values</a></li><li><a href="#Calculating-multiple-degrees/orders">Calculating multiple degrees/orders</a></li><li><a href="#In-place-calculations">In-place calculations</a></li><li><a href="#Precomputed-recursion-factors">Precomputed recursion factors</a></li><li><a href="#Footnotes">Footnotes</a></li></ul></li></ul><h2 id="Calculating-scalar-values"><a class="docs-heading-anchor" href="#Calculating-scalar-values">Calculating scalar values</a><a id="Calculating-scalar-values-1"></a><a class="docs-heading-anchor-permalink" href="#Calculating-scalar-values" title="Permalink"></a></h2><p>At its simplest, the associated Legendre polynomial <span>$P_\ell^m(x)$</span> is computed by calling <a href="../../lib/public/#AssociatedLegendrePolynomials.Plm"><code>Plm</code></a>. For example, to compute <span>$P_2^1(0.5)$</span>,</p><pre><code class="language-julia-repl hljs">julia&gt; using AssociatedLegendrePolynomials

julia&gt; Plm(2, 1, 0.5)
-1.299038105676658</code></pre><p>In the context of CMB analysis, a common use of the associated Legendre polynomials is to compute the spherical harmonics <span>$Y_{\ell m}(\theta,\phi)$</span>:</p><p class="math-container">\[\begin{align}
    \begin{aligned}
    Y_{\ell m}(\theta,\phi) &amp;\equiv N_\ell^m P_\ell^m(\cos \theta) e^{im\phi} \\
    &amp;\text{where } N_\ell^m \equiv \sqrt{\frac{2\ell+1}{4\pi} \frac{(\ell-m)!}{(\ell+m)!}}
    \end{aligned}
\end{align}\]</p><p>The function <a href="../../lib/public/#AssociatedLegendrePolynomials.Nlm"><code>Nlm</code></a> calculates the normalization factor <span>$N_\ell^m$</span>:</p><pre><code class="language-julia-repl hljs">julia&gt; Nlm(2, 0)
0.6307831305050401

julia&gt; Nlm(2, 0) * Plm(2, 0, 0.5)
-0.07884789131313001</code></pre><p>An important fact about the associated Legendre polynomials is that for <span>$m &gt; 0$</span>, <span>$P_\ell^m(x)$</span> diverges to <span>$\infty$</span> as <span>$\ell \rightarrow \infty$</span> <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>. For even moderately large pairs of <span>$(\ell,m)$</span>, numerical underflow and overflow make computing the spherical harmonics impossible this way:</p><pre><code class="language-julia-repl hljs">julia&gt; n = Nlm(157, 150)      # Underflows
0.0

julia&gt; p = Plm(157, 150, 0.5) # Overflows
Inf

julia&gt; n * p                  # Undefined
NaN</code></pre><p>One way around this would be to just use extended precision arithmetic</p><pre><code class="language-julia-repl hljs">julia&gt; n = Nlm(BigFloat, 157, 150)
4.14800666209481424285411223457923933542541063872695815968861285171699012214351e-314

julia&gt; p = Plm(157, 150, big&quot;0.5&quot;)
4.768286486602206390406601862422168575170463348990958242752608686436785229641823e+308

julia&gt; Float64(n * p)
1.9778884113202627e-5</code></pre><p>but at the expense of much more computationally expensive calculations.</p><p>An alternative way forward is to directly calculate the spherical harmonic normalized associated Legendre polynomials <span>$\lambda_\ell^m(x)$</span> so that the spherical harmonics are defined as</p><p class="math-container">\[\begin{align}
    \begin{aligned}
    Y_{\ell m}(\theta,\phi) &amp;= \lambda_\ell^m(\cos \theta) e^{im\phi} \\
    &amp; \text{where } \lambda_\ell^m(x) \equiv N_\ell^m P_\ell^m(x)
    \end{aligned}
\end{align}\]</p><p><a href="../../lib/public/#AssociatedLegendrePolynomials.λlm"><code>λlm</code></a> implements this scheme and avoids the under/overflow of computing the normalization separately from the function:</p><pre><code class="language-julia-repl hljs">julia&gt; λlm(157, 150, 0.5)
1.977888411320263e-5</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>We are not just limited to efficient and numerically stable computation of <span>$\lambda_\ell^m(x)$</span>; the package supports arbitrary normalizations. For further information on implementing custom Legendre normalizations, see the <a href="../devdocs/#customnorm">Custom normalizations</a> section.</p></div></div><h2 id="Calculating-multiple-degrees/orders"><a class="docs-heading-anchor" href="#Calculating-multiple-degrees/orders">Calculating multiple degrees/orders</a><a id="Calculating-multiple-degrees/orders-1"></a><a class="docs-heading-anchor-permalink" href="#Calculating-multiple-degrees/orders" title="Permalink"></a></h2><p>Because calculating a particular Legendre polynomial value is the end result of running a recurrence relation, looping evaluation of <span>$P_\ell^m(x)$</span> for all <span>$\ell$</span> is inefficient and redoes a lot of work:</p><pre><code class="language-julia-repl hljs">julia&gt; @time [l &lt; 2 ? 0.0 : λlm(l, 2, 0.5) for l in 2:700];
  0.039210 seconds (71.21 k allocations: 3.285 MiB)</code></pre><p>It&#39;s far more efficient to accumulate the intermediate terms while running the recurrence relations. Using a <code>UnitRange</code> as the input degree causes the functions to allocate and fill the vector with all polynomials values:</p><pre><code class="language-julia-repl hljs">julia&gt; λ = @time λlm(0:700, 2, 0.5);
  0.000012 seconds (6 allocations: 5.703 KiB)</code></pre><p>On my machine, this is roughly 3000 times faster!</p><p>Likewise, calculating the [lower triangular] matrix of values for some <span>$x$</span> over all degrees <span>$\ell \in [0,\ell_\mathrm{max}]$</span> and all orders <span>$m \in [0,\ell]$</span> is done by also specifying the orders as a <code>UnitRange</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; Λ = @time λlm(0:700, 0:700, 0.5);
  0.002980 seconds (7 allocations: 3.749 MiB)

julia&gt; Λ[:,3] == λ   # N.B. 1-based indexing of the array!
true</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>There are two things in particular to remember with the range-based calls:</p><ol><li>The ranges must start at 0, otherwise an <code>ArgumentError</code> will be thrown.</li><li>Calculating a range of orders <span>$m$</span> for a fixed degree <span>$\ell$</span> is not supported; to calculate multiple orders requires the output matrix be at least square (but may &quot;tall and skinny&quot; with <span>$\ell_\mathrm{max} &gt; m_\mathrm{max}$</span> if desired).</li></ol></div></div><p>It is also more efficient to operate upon an array of arguments <span>$x$</span> than to loop over them one-by-one, so the functions also accept the input argument <code>x</code> as an array of any shape.</p><p>For a specific degree and order, the output array will have the same shape as the argument:</p><pre><code class="language-julia-repl hljs">julia&gt; λlm(2, 0, reshape(range(0, 1, length=4), 2, 2))
2×2 Matrix{Float64}:
 -0.315392  0.105131
 -0.210261  0.630783</code></pre><p>Then adding a range of degrees increases the dimensionality by 1, with the trailing dimension being over <span>$\ell$</span>,</p><pre><code class="language-julia-repl hljs">julia&gt; λlm(0:2, 0, reshape(range(0, 1, length=4), 2, 2))
2×2×3 Array{Float64, 3}:
[:, :, 1] =
 0.282095  0.282095
 0.282095  0.282095

[:, :, 2] =
 0.0       0.325735
 0.162868  0.488603

[:, :, 3] =
 -0.315392  0.105131
 -0.210261  0.630783</code></pre><p>and a further extra dimension is added for a range over orders <span>$m$</span>.</p><h2 id="In-place-calculations"><a class="docs-heading-anchor" href="#In-place-calculations">In-place calculations</a><a id="In-place-calculations-1"></a><a class="docs-heading-anchor-permalink" href="#In-place-calculations" title="Permalink"></a></h2><p>Both of <code>Plm</code> and <code>λlm</code> also have in-place modifying counterparts, <a href="../../lib/public/#AssociatedLegendrePolynomials.Plm!"><code>Plm!</code></a> and <a href="../../lib/public/#AssociatedLegendrePolynomials.λlm!"><code>λlm!</code></a> respectively, which fill an appropriately sized vector for a specified <span>$\ell_\mathrm{max}$</span> and <span>$m_\mathrm{max}$</span>. Instead of using integer or range arguments, whether to calculate a value for a single degree/order, a range of degrees for fixed order, or for all degrees and orders is inferred based on the dimensionality of the output array.</p><p>For example, to calculate the single value <span>$\lambda_{700}^{200}(0.5)$</span>, provide a 0-dimensional output array (to match the 0-dimensionality of the scalar <code>0.5</code>)</p><pre><code class="language-julia-repl hljs">julia&gt; λlm!(fill(NaN), 700, 2, 0.5)
0-dimensional Array{Float64, 0}:
0.24148976866924293</code></pre><p>and filling a vector or matrix instead calculates all degrees up to the given maximum degree/order as appropriate:</p><pre><code class="language-julia-repl hljs">julia&gt; λlm!(λ, 700, 2, 0.5) == λlm(0:700, 2, 0.5)
true

julia&gt; λlm!(Λ, 700, 700, 0.5) == λlm(0:700, 0:700, 0.5)
true</code></pre><p>The in-place interface accepts input arguments <code>x</code> of any shape as well, with the output array <code>Λ</code> having to have between 0 and 2 more dimensions than <code>x</code>, where the leading dimensions of the input and output arrays have the same axes, and the trailing dimensions are sized appropriate for the number of degrees/orders to be calculated.</p><h2 id="Precomputed-recursion-factors"><a class="docs-heading-anchor" href="#Precomputed-recursion-factors">Precomputed recursion factors</a><a id="Precomputed-recursion-factors-1"></a><a class="docs-heading-anchor-permalink" href="#Precomputed-recursion-factors" title="Permalink"></a></h2><p>A final trick to accelerating calculation of any normalization of the associated Legendre polynomials is to pre-compute the appropriate recursion relation coefficients.</p><p>At a low level, <code>Plm</code>/<code>Plm!</code> and <code>λlm</code>/<code>λlm!</code> are simple wrappers around the general <a href="../../lib/public/#AssociatedLegendrePolynomials.legendre"><code>legendre</code></a>/<a href="../../lib/public/#AssociatedLegendrePolynomials.legendre!"><code>legendre!</code></a> functions. The trait type <a href="../../lib/public/#AssociatedLegendrePolynomials.LegendreUnitNorm"><code>LegendreUnitNorm</code></a> dispatches internal functions to compute <span>$P_\ell^m(x)$</span>:</p><pre><code class="language-julia-repl hljs">julia&gt; legendre(LegendreUnitNorm(), 5, 2, 0.5) == Plm(5, 2, 0.5)
true</code></pre><p>and <a href="../../lib/public/#AssociatedLegendrePolynomials.LegendreSphereNorm"><code>LegendreSphereNorm</code></a> does the same for <span>$\lambda_ℓ^m(x)$</span>:</p><pre><code class="language-julia-repl hljs">julia&gt; legendre(LegendreSphereNorm(), 5, 2, 0.5) == λlm(5, 2, 0.5)
true</code></pre><p>The type <a href="../../lib/public/#AssociatedLegendrePolynomials.LegendreNormCoeff"><code>LegendreNormCoeff</code></a> stores the coefficients for a particular normalization (and value type) so that the coefficients must only be calculated once. Aliases for the unit and spherical normalizations are provided by default, <a href="../../lib/public/#AssociatedLegendrePolynomials.LegendreUnitCoeff"><code>LegendreUnitCoeff</code></a> and <a href="../../lib/public/#AssociatedLegendrePolynomials.LegendreSphereCoeff"><code>LegendreSphereCoeff</code></a> respectively.</p><pre><code class="language-julia-repl hljs">julia&gt; coeff = LegendreSphereCoeff{Float64}(700);

julia&gt; legendre(coeff, 5, 2, 0.5)
-0.15888479843070935</code></pre><div class="admonition is-warning"><header class="admonition-header">Performance Note</header><div class="admonition-body"><p>Choosing whether to use the pre-computed coefficients or not should be guided by benchmarking and performance profiling. Modern processors can perform many floating point operations in the time it takes to load the coefficients from memory, so depending on the complexity of the normalization, you may actually achieve better performance by recomputing the recursion coefficients on demand.</p></div></div><p>Notice that due to its flexibility, <code>legendre!</code> requires explicit <code>lmax</code> and <code>mmax</code> arguments even though the <code>LegendreNormCoeff</code> has a <code>lmax</code> and <code>mmax</code> set during construction. This allows us to pass both a coefficient cache and output array which are larger than the computed set of coefficients. For example, the output matrix and cache used above each support computing the Legendre polynomials up to <span>$\ell = 700$</span>, but if we only need <span>$\ell \le 2$</span>, we can avoid computing terms beyond our required problem size.</p><pre><code class="language-julia-repl hljs">julia&gt; fill!(Λ, 0);

julia&gt; legendre!(coeff, Λ, 2, 2, 0.5);

julia&gt; Λ[1:5, 1:5]
5×5 Matrix{Float64}:
  0.282095    0.0       0.0       0.0  0.0
  0.244301   -0.299207  0.0       0.0  0.0
 -0.0788479  -0.334523  0.289706  0.0  0.0
  0.0         0.0       0.0       0.0  0.0
  0.0         0.0       0.0       0.0  0.0</code></pre><hr/><h2 id="Footnotes"><a class="docs-heading-anchor" href="#Footnotes">Footnotes</a><a id="Footnotes-1"></a><a class="docs-heading-anchor-permalink" href="#Footnotes" title="Permalink"></a></h2><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a><p>Specifically, the envelope of <span>$P_\ell^m(x)$</span> which bounds the local extrema for all values of <span>$x$</span> can be shown to be</p><p class="math-container">\[    \left| P_\ell^m(\cos \theta) \right| \le
        \frac{\Gamma(\ell+m+1)}{\Gamma(\ell+\frac{3}{2})}
        \left( \frac{2}{\pi \sin \theta} \right)^{1/2}\]</p><p>(see Eq. 8.10.7 (p336) of Abramowitz and Stegun, “Handbook of Mathematical Functions” 10th printing (1972)). For fixed <span>$m$</span> and any <span>$x$</span>, we take the asymptotic limit as <span>$\ell \rightarrow \infty$</span> and simplify <span>$\Gamma(z)$</span> via Stirling&#39;s approximation to get the scaling of the associated Legendre polynomial envelope</p><p class="math-container">\[    \DeclareMathOperator*{\env}{env}
    \env_{\ell\rightarrow\infty}\left( P_\ell^m \right) \propto \ell^{m - 1/2} \text{ .}\]</p><p>In contrast, the normalization factor <span>$N_\ell^m$</span> scales as <span>$\ell^{1/2 - m}$</span>, exactly canceling the scaling of <span>$\env\left(P_\ell^m\right)$</span>, so overall the spherical harmonic normalized Legendre polynomials <span>$\lambda_\ell^m(x)$</span> asymptote to some constant envelope:</p><p class="math-container">\[    \env_{\ell\rightarrow\infty} \left( \lambda_\ell^m \right) \propto
        \ell^0 = \text{constant .}\]</p></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../intro/">« Introduction</a><a class="docs-footer-nextpage" href="../devdocs/">Developer Documentation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Friday 8 March 2024 20:36">Friday 8 March 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
